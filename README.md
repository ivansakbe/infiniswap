## Infiniswap
### Acerca de
Las aplicaciones con memoria intensiva sufren de una gran perdida de rendimiento cuando su memoria no entra completamente en la memoria fisica. Sin embargo, estos no pueden aprovechar la memoria remota que de otro modo no se usaría cuando se desplazan a los discos e incluso en presencia de un gran desequilibrio en utilizaciones de memoria en el cluster. Las propuestas existentes para la desagregación de memoria requieren de nuevas arquitecturas, nuevos diseños de hardware y/o nuevos modelos de programación, haciendolos inviables.
 Este articulo describe el diseño y la implementación de INFINISWAP, un sistema de mapeo de memoria remota diseñado especificamente para una red RDMA (Remote Direct Memory Access: es un acceso directo a memoria desde la memoria de una computadora dentro de otra sin involucrar el S.O. de la otra computadora). INFINISWAP aprovecha oportunista y exppone transparentemente expone memoria sin usar a aplicaciones sin modificar dividiendo el espacio swap de cada maquina en varios esclavos y distribuyendola a traves de la memoria remota de varias maquinas. Debido a que las operaciones RDMA en un solo lado omiten las cpu remotas, INFINISWAP aprovecha el poder de muchas opciones para realizar locaciones en esclavos descentralizados y desalojos.
Hemos implementado y desarrollado INFINISWAP en un cluster RDMA sin ninguna modificacion a aplicaciones de usuario o del S.O. y evaluamos su efectividad usando multiples cargas de trabajo corriendo sin modificaciones VoltDB, Memcached, PowerGraph, GraphX, y Apache Spark. Usando INFINISWAP, rendimientos de estas aplicaciones mejoraron entre 4x(0.94X) a 15.4X(7.8X) (Mellanox nbdX), y latencias media y cola entre 5.4X(2X) y 61X(2.3X). INFINISWAP logra esto con un usa de CPU remoto despreciable, mientras nbdX se vuelve CPU-ligado. INFINISWAP incrementa la utilización de la memoria en general de un cluster y funciona bien a escala.

### Introducción
Aplicaciones de memoria-intensiva son ampliamente usadas hoy para servicios de baja-latencia y analisis intensivos de datos por igual. La principal razon de su popularidad es simple: mientras las peticiones son servidas de la memoria y los accesos a disco son minimizados, la latencia decrementa y el rendimiento aumenta. Sin embargo estas aplicaciones experimentan un deterioro rapido del rendimiento cuando los conjuntos de trabajo no entran completamente en la memoria.
Hay dos caminos primarios para mitigar este problema: i) redimensionando la asignacion de memoriay ii) incrementando la capacidad de memoria efectiva en la memoria. Redimensionando es dificil por que las aplicaciones siempre sobreestiman sus requerimientos o intentan por asignar para un uso maximo, resultando en una severa subutilizacion y un uso desbalanceado en el cluster. Nuestro analisis en dos grandes clustareas de produccion muestran que mas del 70% del tiempo existe un severo desvalance de utilizacion de memoria en las maquinas.
Propuestas para la desagregación de memoria reconocen este desbalance y exponen un banco de memoria global para todas las maquinas para incrementar las capacidades de memoria efectiva. Estudios recientes sugieren que las redes RDMA modernas pueden llegar los requerimientos de latencia de las arquitecturas de desagregación de memoria para numerosas cargas de trabajo en la memoria. Sin embargo, las propuestas de desagregación de memoria llaman por nuevas arquitecturas, nuevos diseños de hardware, y nuevos modelos de programación, haciendolos inviables.
En este artículo, presentamos INFINISWAP, una nueva escalable, descentralizada solucion de paginacion de memoria remota que habilita la desagregacion de memoria eficiente. Esta diseñada especificamente para redes RDMA para desempeñar una solucion de paginacion de memoria remota cuando aplicaciones no pueden meter toda su memoria en la memoria local. Lo hace si requerir ninguna coordinación o modificaciones a la actual infraestructura, sistemas operativos y aplicaciones.
INFINISWAP no es el primero en explotar el desbalance de memoria y la brecha de la latencia disco-red para la paginación de memoria remota. Sin embargo, a diferencia de las soluciones existentes, este no incurre en un uso alto del CPU remoto, preocupaciones de escalabilidad de la coordinacion central para encontrar maquinas con memoria libre, y perdidas grandes de rendimiento debido a desalojos, y fallas de memoria remota.
INFINISWAP aborda estos desafios por medio de dos componentes primarios: un dispositivo bloque que es usado como espacio swap y un demonio que maneja remotamente la memoria accesible. Ambos estan presentes en cada maquina y trabajan en conjunto sin ninguna coordinación central. El dispositivo bloque infiniswap escribe sincrónicamente a la memoria remota por baja latencia y asincronamente al disco por tolerancia a fallos. Para mitigar altos costos de recuperación de discos con la presencia de desalojos y fallas remotas, dividimos las direcciones de espacio en 
bloques de tamaño fijo y las colocamos a traves de varias memorias remotas en las maquinas. Como resultado, los desalojos y fallas remotas solo afectan el rendimiento de una fraccion de su espacio de direcciones. Para evitar coordinación, aprovechamos el poder de dos opciones para encontrar maquinas remotas con memoria libre disponible. Todas las I/O remotas ocurren via operaciones RDMA.
El demonio INFINISWAP en cada maquina monitorea y preasigna bloques para evitar gastos de asignacion de memoria cuando una particion es mapeada. Tambien monotirea y proactivamente desaloja bloques para minimizar el impacto del rendimiento en aplicaciones locales. Por que las actividades swap en los bloques alojados son transparentes para el demonio, aprovechamos el poder de muchas opciones para realizar un desalojo por lotes sin ninguna coordinacion central.
Implementamos INFINISWAP en el kernel Linux 3.13.0 y desplegado en un cluster de 32 maquinas RDMA a 56 Gbps. Lo evaluamos usando multiples no modificadas aplicaciones de memoria intensiva: VoltDB, Memcached, PowerGraph, GraphX y Apache Spark usando puntos de referencia industriales y cargas de trabajo de produccion. Usando INFINISWAP, los rendimientos mejoran entre 4x(0.94x) y 15.4x(7.8x) sobre disco (Mellanox nbdX), y latencias medianas y de cola por hasta 5.4x(2x) y 61x(2.3x), respectivamente. Las cargas de trabajo pesadas de memoria experimentan una diferencia de rendimiento limitada durante la paginación, mientras que las cargas de trabajo pesadas del CPU experimentan cierta degradación. En comparación con nbdX, INFINISWAP no usa ningun CPY remoto y provee de 2x a 4x ancho de banda mas alto de lectura/escritura. INFINISWAP se puede recuperar de desalojos y fallas remotas mientras sigue proviendo un alto rendimiento en nivel aplicación en comparacion a los discos. Finalmente, sus beneficios se mantienen con la presencia de gran concurrencia y escalabilidad , con un despresiable uso de ancho de banda.
A pesar de su efectividad, INFINISWAP no puede emular transparentemente la desagregacion de memoria para cargas de trabajo pesadas en CPU tales como Spark y VoltDB (diferente a Memcached y PowerGraph) debido a los gastos inherentes de la busqueda (ej cambio de contexto). Todavia lo consideramos util por sus otros beneficios tangibles. Por ejemplo, cuando los conjuntos de trabajo no encajan en memoria, el rendimiento de VoltDB`s se degrada linealmente usando INFINISWAP en lugar de experimentar una caida super linear.
### Motivación
Esta seccion da un panorama necesario necesario y discute los potenciales beneficios de la peginacion a memoria remota en cargas de trabajo de memoria intensiva asi como las oportunidades de hacerlo en clusters de produccion.
#### Antecedentes
##### Paginación: 
Los sistemas operativos modernos soportan memoria virtual para proporcionar aplicaciones con espacios de direcciones más grandes fisicamente posible, usando páginas de tamaño fijo (tipicamnete 4KB) como la unidad de gestion de memoria. Usualmente, hay mas paginas virtuales que fisicas. Las fallas de pagina ocurren cuando una aplicacion direcciona a una direccion virtual, tal pagina no reside en la memoria fisica. Subsecuentemente, el gestor de memoria virtual (VMM) consulta con la tabla de paginacion para brindar esa pagina en la memoria; eso es conocido como paginación. Para hacer espacio para una nueva pagina, el VMM puede necesitar mover una o mas de las ya existentes a un dispositivo de bloque, que es conocido como el espacio swap.
Cada dispotivo bloque que implementa una interface esperada puede usarse como espacio swap. INFINISWAP es escrito como un dispositivo bloque virtual para realizar este rol.
Vea [14] para una descripcion detallada de manejo de memoria y sus muchas optimizaciones en un sistema operativo moderno.
##### Modelo de implementacion de aplicaciones: 
Consideramos una implementacion de aplicacion basada en contenedores, que es común en centros de datos de producción así como modelos de contenedores como servicio (CaaS). Estos clusters usan asignación de recursos o algoritmos de planificación para determinar la compartición de recursos de diferentes aplicaciones y desplegar procesos de aplicación en contenedores para asegurar el aislamiento. Las aplicaciones comienzan paginacion cuando requieren mas memoria que los limites de memoria de los contenedores.
##### Modelo de Red
INFINISWAP requiere una baja latencia, una red RDMA, pero no se hace ninguna suposición sobre una red RDMA especifica (ej. Infiniband vs RoCE) o diametros de red. A pesar de que evaluamos INFINISWAP en una ambiente a pequeña escala, resultados recientes sugieren que esa RDMA desplegada (INFINISWAP) en centros de datos grandes es en efecto factible.

#### Beneficios Potenciales
Para mostrar los ejectos adversos de la paginación, consideramos cuatro tipos de aplicaciones: i) Un punto de referencia TCP corriendo en la bases de datos en meoria VoltDB; dos cargas de trabajo parecidas a Facebook que se ejecuten en el almacén de clave-valor de Memcached; PowerGraph PowerGraph corriendo el algoritmo TunkRank en un conjunto de datos de Twitter; y PageRank corriendo en Apache Spark y GraphX en el conjunto de datos de Twitter. Encontramos que Spark comienza a agitar durante la paginación y no se completa en la mayoria de los casos. Aplazamos la discusión de Spark a la sección y considermaos el resto aqui.
Para evitar externalidades, solo nos enfocamos en el rendimiento de cada servidor individualmente. El uso de la memoria pico que cada uno de estos corre esta alrededor de 10GB , significantemente menor que la memoria total del servidor. Corremos cada aplicación detro de contenedores con diferentes capacidades de memoria: x% en el eje X de la figura 1 refiere a la corrida interior de un contenedor que soporta a lo mucho x% del espacio de trabajo de la aplicación en memoria, y x<100 forza la paginación. Sección 7.2 contiene mas detalles de las configuraciones experimentales.
Remarcamos dos observaciones que muestran grandes beneficios potenciales de INFINISWAp. Primero, la paginación tiene un significante, no-lineal impacto en el rendimiento (Figura 1). Por ejemplo, una reducción del 25% en resultados de espacio de trabajo en memoria en 5.5x y 2.1x perdida de rendimiento para VoltDB y Memcached; en contraste, PowerGraph y GraphX empeoran marginalmente. Sin embargo, otra reducción del 25% hace VoltDB, Memcached, PowerGraph y GraphX arriba de 24X, 17X, 8X, y 23X peor, respectivamente.
Segundo, las implicaciones de la paginación estan particularmente remarcadas en las latencias de la cola. Como los espacios de trabajo no caben en la memoria, el 99% de las latencias de VoltDB y Memcached son peores por 71.5X y 21.5X, respaecivamente. En contraste, sus latencias medias son peores por arriba de 5.7X y 1.1X, respectivamente.
Estas brechas gigantescas de rendimiento sugieren a teorico, la solución de 100% desagregación de memoria eficiente puede resultar en grandes beneficios, asumiendo que todo lo que requieren tales soluciones está garantizado. Esto tambien muestra que puenteando varias de estas brechas por una practica, desplegable solución puede valer la pena.
#### Caracteristicas del desequilibrio de memoria.
Para entender la presencia del desequilibrio de memoria en los clusters modernos y oportunidades correspondientes, analizamos trazas de dos clusters de producción: i) un cluster de analisis de datos de 3000-maquinas (Facebook) y ii) un cluster de 12500 maquinas (Google) corriendo una mezcla de deversas aplicaiones cortas y grandes corriendo.
Remarcamos dos observaciones clave- la presencia de desequilibrio y sus variables temporales - que guian las desiciones diseñadas de INFINISWAP.
##### Presencia de desequilibrio
Encontramos que el uso de memoria a traves de las maquinas puede estar sustancialmente desbalanceada en el corto plazo (ej decenas de segundos). Causas del desequilibrio incluye la colocación y restricciones de programación y la fragmentación de recursos durante el empaquetamiento, entre otros. Medimos el desequilidria de la utilización de memoria calculando el 99% del uso medio sobre intervalos de 10 segundos. Con un perfecto balance, estos valores deban ser 1. Sin embargo, encontramos que este valor es 2.4 en Facebook y 3.35 en Google mas de la mitad del tiempo; significando, la mayor parte del tiempo, mas de la mitad de la memoria del cluster permanece sin utilizar.
##### Variabilidades Temporales
Aunque sesgado, las utilizaciones de memoria se mantuvieron estables por intervalos cortos, lo cual es útil para la toma de decisiones predecible cuando se seleccionan maquinas remotas. Para analizar la estabilidad de utilizaciones de memoria, adoptamos la metodologia descrita por Chowdhury at al. Especialmente, consideramos una utilización de memoria de maquina Ut(m) al tiempo para estar estable por la duración de T en la diferencia entre Ut(m) y el valor promedio de Ut(m) sobre el intervalo [t,t+T] permanece denro del 10% de Ut(m). Hemos observado que la utilización promedio de memoria de una maquina permanece estable por pequeñas duraciones con muy altas probabilidades. Para la maquina mas impredecible en el cluster de Facebook, las probabilidades que es la utilización de memoria actual para cada instante no cambiara por mas de 10% por los siguientes 10, 20 y 40 segundos donde 0.74, 0.58 y 0.42, respectivamente. Para Google, los numeros correspondientes fueron 0.97, 0.94 y 0.89, respectivamente. Creemos que las altas probabilidades en el cluster Google es debido a sus servicios de larga duración, mientras que el cluster Facebook corre analisis de datos con tareas mas cortas.

### Información General INFINISWAP

INFINISWAP es una solución descentralizada de desagragación de memoria para clusters RDMA que oportunamente usa memoria remota para paginación. En esta sección, presentamos un panorama de INFINISWAP para ayudar al lector seguir como INFINISWAP realiza una desagregación de memoria eficiente y tolerante a fallos, como habilita rapida y transparentemente la reclamación de memoria, y los detalles de implementación.

#### Planteamiento del problema

El objetivo principal de INFINISWAP es el de eficientemente exponer toda la memoria del cluster a las aplicaciones de usuario sin ninguna modificación a estas aplicaciones o a los sistemas operativos de las maquinas. Tambien debe ser escalable, tolerante a fallos, y transparente y que el rendimiento de las aplicaciones en las maquinas remotas no sea afectado.

#### Arquitectural overview
